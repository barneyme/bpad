<!doctype html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>bPad</title>
        <link
            rel="icon"
            href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' width='16' height='16' viewBox='0 0 16 16'><rect width='16' height='16' fill='%23666666'/><text x='8' y='12' font-family='monospace' font-size='12' fill='white' text-anchor='middle'>b</text></svg>"
        />
        <style>
            * {
                margin: 0;
                padding: 0;
                box-sizing: border-box;
            }

            body {
                font-family: "Courier New", monospace;
                background: #f8f8f8;
                height: 100vh;
                position: relative;
                transition: background 0.3s ease;
            }

            body.dark-mode {
                background: #1a1a1a;
            }

            #editor {
                width: 100%;
                height: 100vh;
                border: none;
                outline: none;
                padding: 20px;
                font-family: "Courier New", monospace;
                font-size: 14px;
                line-height: 1.5;
                background: white;
                color: #333;
                resize: none;
                white-space: pre-wrap;
                word-wrap: break-word;
                transition:
                    background 0.3s ease,
                    color 0.3s ease,
                    border 0.2s ease;
            }

            #editor.drag-over {
                border: 3px dashed #007acc;
                background: rgba(0, 122, 204, 0.1);
            }

            body.dark-mode #editor {
                background: #2d2d2d;
                color: #e0e0e0;
            }

            body.dark-mode #editor.drag-over {
                border: 3px dashed #4a9eff;
                background: rgba(74, 158, 255, 0.1);
            }

            #bufferBar {
                display: none;
            }

            #fileInput {
                display: none;
            }

            #mobileControls {
                position: fixed;
                top: 10px;
                right: 10px;
                display: none;
                gap: 8px;
                z-index: 1000;
            }

            .mobile-btn {
                width: 40px;
                height: 40px;
                background: rgba(0, 0, 0, 0.8);
                color: white;
                border: none;
                border-radius: 4px;
                cursor: pointer;
                display: flex;
                align-items: center;
                justify-content: center;
                font-size: 16px;
                transition: background 0.2s;
            }

            .mobile-btn:hover {
                background: rgba(0, 0, 0, 0.9);
            }

            .mobile-btn:active {
                transform: scale(0.95);
            }

            @media (max-width: 768px) {
                #mobileControls {
                    display: flex;
                }

                #editor {
                    height: 100vh;
                }
            }

            #contextMenu {
                position: fixed;
                display: none;
                background: #f0f0f0;
                border: 1px solid #ccc;
                box-shadow: 2px 2px 5px rgba(0, 0, 0, 0.15);
                border-radius: 4px;
                padding: 5px 0;
                z-index: 2000;
                font-size: 14px;
                color: #333;
            }

            .context-menu-item {
                padding: 8px 15px;
                cursor: pointer;
                transition: background 0.2s ease;
            }

            .context-menu-item:hover {
                background: #007acc;
                color: white;
            }

            .context-menu-divider {
                border: none;
                border-top: 1px solid #e0e0e0;
                margin: 4px 0;
            }

            body.dark-mode #contextMenu {
                background: #3a3a3a;
                border-color: #555;
                color: #e0e0e0;
            }

            body.dark-mode .context-menu-item:hover {
                background: #4a9eff;
                color: #1a1a1a;
            }

            body.dark-mode .context-menu-divider {
                border-top-color: #555;
            }

            /* Command Palette Styles */
            #commandPalette {
                position: fixed;
                top: 20%;
                left: 50%;
                transform: translateX(-50%);
                width: 90%;
                max-width: 500px;
                background: #f0f0f0;
                border: 1px solid #ccc;
                border-radius: 8px;
                box-shadow: 0 5px 20px rgba(0, 0, 0, 0.2);
                z-index: 3000;
                overflow: hidden;
            }

            body.dark-mode #commandPalette {
                background: #2d2d2d;
                border-color: #555;
            }

            #commandInput {
                width: 100%;
                padding: 12px 15px;
                border: none;
                outline: none;
                font-family: "Courier New", monospace;
                font-size: 16px;
                background: #fff;
                color: #333;
                border-bottom: 1px solid #ccc;
            }

            body.dark-mode #commandInput {
                background: #3a3a3a;
                color: #e0e0e0;
                border-bottom-color: #555;
            }

            #commandList {
                max-height: 300px;
                overflow-y: auto;
            }

            .command-item {
                padding: 10px 15px;
                cursor: pointer;
                font-size: 14px;
                color: #333;
                display: flex;
                justify-content: space-between;
                align-items: center;
            }

            body.dark-mode .command-item {
                color: #e0e0e0;
            }

            .command-item:hover,
            .command-item.selected {
                background-color: #007acc;
                color: white;
            }

            body.dark-mode .command-item:hover,
            body.dark-mode .command-item.selected {
                background-color: #4a9eff;
                color: #1a1a1a;
            }

            .command-item .shortcut {
                font-size: 12px;
                opacity: 0.7;
            }

            /* Help Modal */
            #helpModal {
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                width: 90%;
                max-width: 600px;
                background: #fff;
                border-radius: 8px;
                box-shadow: 0 5px 20px rgba(0, 0, 0, 0.3);
                z-index: 4000;
                padding: 20px;
                border: 1px solid #ccc;
            }

            #helpModal .help-content {
                position: relative;
            }

            #closeHelpBtn {
                position: absolute;
                top: -10px;
                right: -5px;
                background: none;
                border: none;
                font-size: 24px;
                cursor: pointer;
                color: #888;
            }

            #helpModal h3 {
                margin-bottom: 15px;
                text-align: center;
                color: #333;
            }

            #helpModal pre {
                background: #f8f8f8;
                padding: 15px;
                border-radius: 4px;
                white-space: pre-wrap;
                font-family: "Courier New", monospace;
                font-size: 13px;
                color: #333;
                line-height: 1.6;
            }

            body.dark-mode #helpModal {
                background: #2d2d2d;
                border-color: #555;
            }
            body.dark-mode #helpModal h3,
            body.dark-mode #closeHelpBtn {
                color: #e0e0e0;
            }
            body.dark-mode #helpModal pre {
                background: #1a1a1a;
                color: #e0e0e0;
            }

            .hidden {
                display: none !important;
            }

            .modal-backdrop {
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0, 0, 0, 0.5);
                z-index: 2999;
            }
        </style>
    </head>
    <body>
        <textarea
            id="editor"
            placeholder="Start typing or press Ctrl\Cmd + K for menu."
        ></textarea>

        <div id="commandPalette" class="hidden">
            <div class="palette-container">
                <input
                    type="text"
                    id="commandInput"
                    placeholder="Search commands or files..."
                    autocomplete="off"
                />
                <div id="commandList"></div>
            </div>
        </div>

        <div id="helpModal" class="hidden">
            <div class="help-content">
                <button id="closeHelpBtn">&times;</button>
                <h3>bPad Help & Shortcuts</h3>
                <pre id="helpText">
..................................
bPad : browser Pad
..................................
<div id="currentBuffer">Buffer: 1/1 - bpad.txt</div>
<div id="wordCount">Words: 0 | Lines: 0</div>
..................................
HELP
..................................
Ctrl/Cmd + K : Open command palette
Ctrl/Cmd + N : New tab
bpad.me/abc  : New note 'abc'
Ctrl/Cmd + O : Open file
Drag & drop  : Open file
Ctrl/Cmd + S : Save file
Ctrl/Cmd + W : Close buffer
Ctrl/Cmd + D : Dark/light mode
Ctrl/Cmd + = : Lock/unlock note
Ctrl/Cmd + 1~9 : Switch buffers
Ctrl/Cmd + ←/→ : Switch buffers
F11          : Full screen
Right-click  : Context Menu
..................................
Files auto-save in browser.
Opening a file adds it to a new buffer.
Made by [Barney](www.barney.me)
..................................
                </pre>
            </div>
        </div>

        <div id="contextMenu">
            <div class="context-menu-item" id="ctxCommandPalette">
                Command Palette...
            </div>
            <hr class="context-menu-divider" />
            <div class="context-menu-item" id="ctxNewTab">New Tab</div>
            <div class="context-menu-item" id="ctxOpenFile">Open File...</div>
            <div class="context-menu-item" id="ctxSaveFile">Save File</div>
            <hr class="context-menu-divider" />
            <div class="context-menu-item" id="ctxNextBuffer">Next Buffer</div>
            <div class="context-menu-item" id="ctxPrevBuffer">
                Previous Buffer
            </div>
            <div class="context-menu-item" id="ctxCloseBuffer">
                Close Buffer
            </div>
            <hr class="context-menu-divider" />
            <div class="context-menu-item" id="ctxToggleLock">
                Lock/Unlock Note
            </div>
            <div class="context-menu-item" id="ctxToggleDark">
                Toggle Dark Mode
            </div>
            <div class="context-menu-item" id="ctxToggleFullscreen">
                Fullscreen
            </div>
        </div>

        <div id="mobileControls">
            <button class="mobile-btn" id="openBtn" title="Open file">
                📁
            </button>
            <button class="mobile-btn" id="saveBtn" title="Save file">
                💾
            </button>
        </div>

        <input type="file" id="fileInput" accept=".txt,.md,.js,.html,.css" />

        <script>
            document.addEventListener("DOMContentLoaded", function () {
                // Get DOM elements
                const editor = document.getElementById("editor");
                const fileInput = document.getElementById("fileInput");
                const openBtn = document.getElementById("openBtn");
                const saveBtn = document.getElementById("saveBtn");
                const wordCount = document.getElementById("wordCount");
                const currentBuffer = document.getElementById("currentBuffer");
                const contextMenu = document.getElementById("contextMenu");
                const commandPalette =
                    document.getElementById("commandPalette");
                const commandInput = document.getElementById("commandInput");
                const commandList = document.getElementById("commandList");
                const helpModal = document.getElementById("helpModal");
                const closeHelpBtn = document.getElementById("closeHelpBtn");

                // Crypto constants
                const ENCRYPTION_ALGORITHM = "AES-GCM";
                const KEY_DERIVATION_ALGORITHM = "PBKDF2";
                const HASH_ALGORITHM = "SHA-256";
                const KEY_DERIVATION_ITERATIONS = 100000;

                let tabId;
                let buffers = [];
                let activeBufferIndex = 0;
                let commandPaletteOpen = false;
                let currentCommands = [];

                function initializeTabAndUrl() {
                    const path = window.location.pathname;
                    const pathSegments = path
                        .split("/")
                        .filter(
                            (segment) => segment && segment !== "index.html",
                        );
                    const lastSegment =
                        pathSegments.length > 0
                            ? pathSegments[pathSegments.length - 1]
                            : null;
                    const hasIdInUrl =
                        lastSegment && !lastSegment.includes(".");

                    if (hasIdInUrl) {
                        tabId = lastSegment;
                        localStorage.setItem("bedit_main_tabId", tabId);
                    } else {
                        const storedMainId =
                            localStorage.getItem("bedit_main_tabId");
                        if (storedMainId) {
                            tabId = storedMainId;
                            const basePath = path.endsWith("/")
                                ? path
                                : path.substring(0, path.lastIndexOf("/") + 1);
                            window.history.replaceState(
                                {},
                                "",
                                `${basePath}${tabId}`,
                            );
                        } else {
                            tabId = Math.random().toString(36).substr(2, 6);
                            localStorage.setItem("bedit_main_tabId", tabId);
                            const basePath = path.endsWith("/")
                                ? path
                                : path.substring(0, path.lastIndexOf("/") + 1);
                            window.history.replaceState(
                                {},
                                "",
                                `${basePath}${tabId}`,
                            );
                        }
                    }
                }

                function getFileNameForUrl(fileName) {
                    const nameWithoutExt = fileName.replace(/\.[^/.]+$/, "");
                    return nameWithoutExt
                        .toLowerCase()
                        .replace(/[^a-z0-9]/g, "");
                }

                function updateUrlForCurrentBuffer() {
                    const buffer = buffers[activeBufferIndex];
                    if (!buffer) return;

                    let urlPath;
                    if (buffer.name === "bpad.txt") {
                        urlPath = `/${tabId}`;
                    } else {
                        const urlName = getFileNameForUrl(buffer.name);
                        urlPath = `/${urlName}`;
                    }
                    const currentPath = window.location.pathname;
                    const basePath = currentPath.substring(
                        0,
                        currentPath.lastIndexOf("/") + 1,
                    );
                    const newPath = `${basePath}${urlPath.substring(1)}`;

                    if (window.location.pathname !== newPath) {
                        window.history.replaceState({}, "", newPath);
                    }
                }

                class FileBuffer {
                    constructor(
                        name = "bpad.txt",
                        content = "",
                        fileHandle = null,
                        isLocked = false,
                        encryptedContent = null,
                        salt = null,
                        iv = null,
                    ) {
                        this.name = name;
                        this.content = content;
                        this.originalContent = content;
                        this.fileHandle = fileHandle;
                        this.id = Math.random().toString(36).substr(2, 9);
                        this.isLocked = isLocked;
                        this.encryptedContent = encryptedContent;
                        this.salt = salt;
                        this.iv = iv;
                    }
                    get isModified() {
                        if (this.isLocked) return false;
                        return this.content !== this.originalContent;
                    }
                    markSaved() {
                        this.originalContent = this.content;
                    }
                }

                async function deriveKey(password, salt) {
                    const enc = new TextEncoder();
                    const keyMaterial = await window.crypto.subtle.importKey(
                        "raw",
                        enc.encode(password),
                        { name: KEY_DERIVATION_ALGORITHM },
                        false,
                        ["deriveKey"],
                    );
                    return window.crypto.subtle.deriveKey(
                        {
                            name: KEY_DERIVATION_ALGORITHM,
                            salt: salt,
                            iterations: KEY_DERIVATION_ITERATIONS,
                            hash: HASH_ALGORITHM,
                        },
                        keyMaterial,
                        { name: ENCRYPTION_ALGORITHM, length: 256 },
                        true,
                        ["encrypt", "decrypt"],
                    );
                }

                async function encryptText(text, password) {
                    const salt = window.crypto.getRandomValues(
                        new Uint8Array(16),
                    );
                    const iv = window.crypto.getRandomValues(
                        new Uint8Array(12),
                    );
                    const key = await deriveKey(password, salt);
                    const enc = new TextEncoder();
                    const encodedText = enc.encode(text);
                    const encryptedContent = await window.crypto.subtle.encrypt(
                        { name: ENCRYPTION_ALGORITHM, iv: iv },
                        key,
                        encodedText,
                    );
                    return {
                        encryptedContent: btoa(
                            String.fromCharCode.apply(
                                null,
                                new Uint8Array(encryptedContent),
                            ),
                        ),
                        salt: btoa(String.fromCharCode.apply(null, salt)),
                        iv: btoa(String.fromCharCode.apply(null, iv)),
                    };
                }

                async function decryptText(
                    encryptedContentB64,
                    password,
                    saltB64,
                    ivB64,
                ) {
                    try {
                        const salt = new Uint8Array(
                            atob(saltB64)
                                .split("")
                                .map((c) => c.charCodeAt(0)),
                        );
                        const iv = new Uint8Array(
                            atob(ivB64)
                                .split("")
                                .map((c) => c.charCodeAt(0)),
                        );
                        const encryptedContent = new Uint8Array(
                            atob(encryptedContentB64)
                                .split("")
                                .map((c) => c.charCodeAt(0)),
                        );
                        const key = await deriveKey(password, salt);
                        const decryptedContent =
                            await window.crypto.subtle.decrypt(
                                { name: ENCRYPTION_ALGORITHM, iv: iv },
                                key,
                                encryptedContent,
                            );
                        const dec = new TextDecoder();
                        return dec.decode(decryptedContent);
                    } catch (e) {
                        console.error("Decryption failed:", e);
                        return null;
                    }
                }

                function saveBuffersToLocalStorage() {
                    const buffersToSave = buffers.map((buffer) => ({
                        name: buffer.name,
                        content: buffer.isLocked ? "" : buffer.content,
                        originalContent: buffer.originalContent,
                        isLocked: buffer.isLocked,
                        encryptedContent: buffer.encryptedContent,
                        salt: buffer.salt,
                        iv: buffer.iv,
                    }));
                    localStorage.setItem(
                        `bedit_buffers_${tabId}`,
                        JSON.stringify(buffersToSave),
                    );
                    localStorage.setItem(
                        `bedit_active_buffer_index_${tabId}`,
                        activeBufferIndex,
                    );
                }

                function initializeBuffers() {
                    const savedBuffersData = localStorage.getItem(
                        `bedit_buffers_${tabId}`,
                    );
                    if (savedBuffersData) {
                        const savedBuffers = JSON.parse(savedBuffersData);
                        buffers = savedBuffers.map(
                            (b) =>
                                new FileBuffer(
                                    b.name,
                                    b.content,
                                    null,
                                    b.isLocked,
                                    b.encryptedContent,
                                    b.salt,
                                    b.iv,
                                ),
                        );
                        activeBufferIndex =
                            parseInt(
                                localStorage.getItem(
                                    `bedit_active_buffer_index_${tabId}`,
                                ),
                                10,
                            ) || 0;
                        if (activeBufferIndex >= buffers.length)
                            activeBufferIndex = 0;
                    } else {
                        const oldContentKey = `bedit_${tabId}_editorContent`;
                        const savedContent =
                            localStorage.getItem(oldContentKey) || "";
                        buffers = [new FileBuffer("bpad.txt", savedContent)];
                        activeBufferIndex = 0;
                        if (localStorage.getItem(oldContentKey)) {
                            saveBuffersToLocalStorage();
                            localStorage.removeItem(oldContentKey);
                        }
                    }
                    if (buffers.length === 0) {
                        buffers = [new FileBuffer("bpad.txt", "")];
                        activeBufferIndex = 0;
                    }
                    updateBufferBar();
                    loadActiveBuffer();
                }

                function createNewBuffer(
                    name = "bpad.txt",
                    content = "",
                    fileHandle = null,
                ) {
                    const buffer = new FileBuffer(name, content, fileHandle);
                    buffers.push(buffer);
                    activeBufferIndex = buffers.length - 1;
                    updateBufferBar();
                    loadActiveBuffer();
                    updateUrlForCurrentBuffer();
                    saveBuffersToLocalStorage();
                    return buffer;
                }

                function switchToBuffer(index) {
                    if (index < 0 || index >= buffers.length) return;
                    const currentBuf = buffers[activeBufferIndex];
                    if (currentBuf && !currentBuf.isLocked) {
                        currentBuf.content = editor.value;
                    }
                    activeBufferIndex = index;
                    loadActiveBuffer();
                    updateBufferBar();
                    updateUrlForCurrentBuffer();
                    saveBuffersToLocalStorage();
                }

                function closeBuffer(index) {
                    if (buffers.length === 1) return;
                    const buffer = buffers[index];
                    if (buffer.isModified && !buffer.isLocked) {
                        if (
                            !confirm(
                                `"${buffer.name}" has unsaved changes. Close anyway?`,
                            )
                        ) {
                            return;
                        }
                    }
                    buffers.splice(index, 1);
                    if (activeBufferIndex >= index && activeBufferIndex > 0) {
                        activeBufferIndex--;
                    } else if (activeBufferIndex >= buffers.length) {
                        activeBufferIndex = buffers.length - 1;
                    }
                    updateBufferBar();
                    loadActiveBuffer();
                    updateUrlForCurrentBuffer();
                    saveBuffersToLocalStorage();
                }

                function loadActiveBuffer() {
                    const buffer = buffers[activeBufferIndex];
                    if (buffer) {
                        if (buffer.isLocked) {
                            editor.value = "";
                            editor.placeholder =
                                "🔒 This note is locked. Press Ctrl/Cmd + = to unlock.";
                            editor.readOnly = true;
                        } else {
                            editor.value = buffer.content;
                            editor.placeholder =
                                "Start typing or press Ctrl\\Cmd + K for menu.";
                            editor.readOnly = false;
                        }
                        updateWordCount();
                        updateBufferBar();
                        editor.focus();
                    }
                }

                function updateBufferBar() {
                    if (currentBuffer) {
                        const buffer = buffers[activeBufferIndex];
                        if (!buffer) return;
                        const modifiedText =
                            buffer.isModified && !buffer.isLocked
                                ? " (modified)"
                                : "";
                        const lockedText = buffer.isLocked ? " 🔒" : "";
                        currentBuffer.textContent = `Buffer: ${
                            activeBufferIndex + 1
                        }/${buffers.length} - ${buffer.name}${lockedText}${modifiedText}`;
                    }
                }

                function loadDarkMode() {
                    const isDarkMode =
                        localStorage.getItem("darkMode") === "true";
                    if (isDarkMode) document.body.classList.add("dark-mode");
                }

                function toggleDarkMode() {
                    document.body.classList.toggle("dark-mode");
                    localStorage.setItem(
                        "darkMode",
                        document.body.classList.contains("dark-mode"),
                    );
                }

                function updateWordCount() {
                    const text = editor.value;
                    const words =
                        text.trim() === ""
                            ? 0
                            : text.trim().split(/\s+/).length;
                    const lines = text === "" ? 0 : text.split("\n").length;
                    wordCount.textContent = `Words: ${words} | Lines: ${lines}`;
                }

                async function saveFile() {
                    const buffer = buffers[activeBufferIndex];
                    if (!buffer) return;
                    if (buffer.isLocked) {
                        showSaveIndicator("Cannot save a locked note!");
                        return;
                    }
                    const content = editor.value;
                    buffer.content = content;
                    if ("showSaveFilePicker" in window && buffer.fileHandle) {
                        try {
                            const writable =
                                await buffer.fileHandle.createWritable();
                            await writable.write(content);
                            await writable.close();
                            buffer.markSaved();
                            updateBufferBar();
                            showSaveIndicator("Saved!");
                            return;
                        } catch (err) {
                            console.log("Direct save failed:", err);
                        }
                    }
                    if ("showSaveFilePicker" in window && !buffer.fileHandle) {
                        try {
                            buffer.fileHandle = await window.showSaveFilePicker(
                                {
                                    suggestedName: buffer.name,
                                    types: [
                                        {
                                            description: "Text files",
                                            accept: { "text/plain": [".txt"] },
                                        },
                                    ],
                                },
                            );
                            const writable =
                                await buffer.fileHandle.createWritable();
                            await writable.write(content);
                            await writable.close();
                            buffer.name = buffer.fileHandle.name;
                            buffer.markSaved();
                            updateBufferBar();
                            updateUrlForCurrentBuffer();
                            showSaveIndicator("Saved!");
                            return;
                        } catch (err) {
                            if (err.name !== "AbortError") {
                                console.log("Save picker failed:", err);
                            }
                        }
                    }
                    const blob = new Blob([content], { type: "text/plain" });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement("a");
                    a.href = url;
                    a.download = buffer.name;
                    a.click();
                    URL.revokeObjectURL(url);
                    buffer.markSaved();
                    updateBufferBar();
                    showSaveIndicator("Downloaded!");
                }

                function showSaveIndicator(message) {
                    let indicator = document.getElementById("saveIndicator");
                    if (!indicator) {
                        indicator = document.createElement("div");
                        indicator.id = "saveIndicator";
                        indicator.style.cssText = `position: fixed; top: 20px; left: 50%; transform: translateX(-50%); background: rgba(0, 150, 0, 0.9); color: white; padding: 8px 16px; border-radius: 4px; font-size: 14px; z-index: 2000; opacity: 0; transition: opacity 0.3s; pointer-events: none;`;
                        document.body.appendChild(indicator);
                    }
                    indicator.textContent = message;
                    indicator.style.opacity = "1";
                    setTimeout(() => {
                        indicator.style.opacity = "0";
                    }, 2000);
                }

                async function openFile() {
                    if ("showOpenFilePicker" in window) {
                        try {
                            const [handle] = await window.showOpenFilePicker({
                                multiple: false,
                            });
                            const file = await handle.getFile();
                            const content = await file.text();
                            createNewBuffer(file.name, content, handle);
                        } catch (err) {
                            if (err.name !== "AbortError") {
                                console.log("File picker failed:", err);
                            }
                        }
                    } else {
                        fileInput.click();
                    }
                }

                async function toggleLock() {
                    const buffer = buffers[activeBufferIndex];
                    if (!buffer) return;
                    if (buffer.isLocked) {
                        const password = prompt("Enter password to unlock:");
                        if (!password) return;
                        const decryptedContent = await decryptText(
                            buffer.encryptedContent,
                            password,
                            buffer.salt,
                            buffer.iv,
                        );
                        if (decryptedContent !== null) {
                            buffer.content = decryptedContent;
                            buffer.isLocked = false;
                            buffer.encryptedContent = null;
                            buffer.salt = null;
                            buffer.iv = null;
                            showSaveIndicator("Note unlocked!");
                        } else {
                            alert("Decryption failed. Incorrect password.");
                            return;
                        }
                    } else {
                        const password = prompt("Enter password to lock note:");
                        if (!password) {
                            alert("Password cannot be empty.");
                            return;
                        }
                        const passwordConfirm = prompt("Confirm password:");
                        if (password !== passwordConfirm) {
                            alert("Passwords do not match.");
                            return;
                        }
                        const { encryptedContent, salt, iv } =
                            await encryptText(editor.value, password);
                        buffer.encryptedContent = encryptedContent;
                        buffer.salt = salt;
                        buffer.iv = iv;
                        buffer.isLocked = true;
                        buffer.content = "";
                        showSaveIndicator("Note locked!");
                    }
                    saveBuffersToLocalStorage();
                    loadActiveBuffer();
                }

                function newTab() {
                    const newId = Math.random().toString(36).substr(2, 6);
                    const currentPath = window.location.pathname;
                    const basePath = currentPath.substring(
                        0,
                        currentPath.lastIndexOf("/") + 1,
                    );
                    const newUrl = `${window.location.origin}${basePath}${newId}`;
                    window.open(newUrl, "_blank");
                }

                function toggleFullscreen() {
                    if (!document.fullscreenElement) {
                        document.documentElement.requestFullscreen();
                    } else {
                        document.exitFullscreen();
                    }
                }

                function showContextMenu(x, y) {
                    contextMenu.style.left = `${x}px`;
                    contextMenu.style.top = `${y}px`;
                    contextMenu.style.display = "block";
                }

                function hideContextMenu() {
                    contextMenu.style.display = "none";
                }

                // --- Command Palette Logic ---
                function openCommandPalette() {
                    populateCommands();
                    renderCommands(currentCommands);
                    commandPalette.classList.remove("hidden");
                    document.body.insertAdjacentHTML(
                        "beforeend",
                        '<div id="modalBackdrop" class="modal-backdrop"></div>',
                    );
                    commandInput.value = "";
                    commandInput.focus();
                    commandPaletteOpen = true;

                    document
                        .getElementById("modalBackdrop")
                        .addEventListener("click", closeCommandPalette);
                }

                function closeCommandPalette() {
                    commandPalette.classList.add("hidden");
                    const backdrop = document.getElementById("modalBackdrop");
                    if (backdrop) backdrop.remove();
                    commandPaletteOpen = false;
                    editor.focus();
                }

                function showHelp() {
                    helpModal.classList.remove("hidden");
                    if (!document.getElementById("modalBackdrop")) {
                        document.body.insertAdjacentHTML(
                            "beforeend",
                            '<div id="modalBackdrop" class="modal-backdrop"></div>',
                        );
                        document
                            .getElementById("modalBackdrop")
                            .addEventListener("click", closeHelpModal);
                    }
                }

                function closeHelpModal() {
                    helpModal.classList.add("hidden");
                    const backdrop = document.getElementById("modalBackdrop");
                    if (backdrop) backdrop.remove();
                    editor.focus();
                }

                const staticCommands = [
                    { name: "Show Help", action: showHelp, shortcut: "?" },
                    { name: "Save File", action: saveFile, shortcut: "Ctrl+S" },
                    {
                        name: "Open File...",
                        action: openFile,
                        shortcut: "Ctrl+O",
                    },
                    { name: "New Tab", action: newTab, shortcut: "Ctrl+N" },
                    {
                        name: "Toggle Dark/Light Mode",
                        action: toggleDarkMode,
                        shortcut: "Ctrl+D",
                    },
                    {
                        name: "Lock/Unlock Note",
                        action: toggleLock,
                        shortcut: "Ctrl+=",
                    },
                    {
                        name: "Close Current Buffer",
                        action: () => closeBuffer(activeBufferIndex),
                        shortcut: "Ctrl+W",
                    },
                    {
                        name: "Toggle Fullscreen",
                        action: toggleFullscreen,
                        shortcut: "F11",
                    },
                ];

                function populateCommands() {
                    const bufferCommands = buffers.map((buf, index) => ({
                        name: `Switch to: ${buf.name}`,
                        action: () => switchToBuffer(index),
                        shortcut: `Buffer ${index + 1}`,
                    }));
                    currentCommands = [...staticCommands, ...bufferCommands];
                }

                function renderCommands(commandsToRender) {
                    commandList.innerHTML = "";
                    commandsToRender.forEach((cmd, index) => {
                        const item = document.createElement("div");
                        item.className = "command-item";
                        item.dataset.index = index;

                        const nameSpan = document.createElement("span");
                        nameSpan.textContent = cmd.name;

                        const shortcutSpan = document.createElement("span");
                        shortcutSpan.className = "shortcut";
                        shortcutSpan.textContent = cmd.shortcut;

                        item.appendChild(nameSpan);
                        item.appendChild(shortcutSpan);

                        item.addEventListener("click", () => {
                            cmd.action();
                            closeCommandPalette();
                        });
                        commandList.appendChild(item);
                    });
                    if (commandList.firstChild) {
                        commandList.firstChild.classList.add("selected");
                    }
                }

                commandInput.addEventListener("input", () => {
                    const searchTerm = commandInput.value.toLowerCase();
                    const filteredCommands = currentCommands.filter((cmd) =>
                        cmd.name.toLowerCase().includes(searchTerm),
                    );
                    renderCommands(filteredCommands);
                });

                // Event Listeners
                editor.addEventListener("input", function () {
                    const buffer = buffers[activeBufferIndex];
                    if (buffer && !buffer.isLocked) {
                        buffer.content = editor.value;
                        updateBufferBar();
                        saveBuffersToLocalStorage();
                    }
                    updateWordCount();
                });

                fileInput.addEventListener("change", (e) => {
                    if (e.target.files[0]) loadFileContent(e.target.files[0]);
                });

                function loadFileContent(file) {
                    const reader = new FileReader();
                    reader.onload = (e) =>
                        createNewBuffer(file.name, e.target.result, null);
                    reader.readAsText(file);
                }

                // Drag and drop
                editor.addEventListener("dragover", (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    editor.classList.add("drag-over");
                });
                editor.addEventListener("dragleave", (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    if (!editor.contains(e.relatedTarget)) {
                        editor.classList.remove("drag-over");
                    }
                });
                editor.addEventListener("drop", (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    editor.classList.remove("drag-over");
                    if (e.dataTransfer.files.length > 0) {
                        loadFileContent(e.dataTransfer.files[0]);
                    }
                });

                // Mobile buttons
                openBtn.addEventListener("click", openFile);
                saveBtn.addEventListener("click", saveFile);
                closeHelpBtn.addEventListener("click", closeHelpModal);

                // Keyboard shortcuts
                document.addEventListener("keydown", async (e) => {
                    if (commandPaletteOpen) {
                        const items =
                            commandList.querySelectorAll(".command-item");
                        let selected = commandList.querySelector(".selected");

                        if (e.key === "ArrowDown") {
                            e.preventDefault();
                            if (selected && selected.nextElementSibling) {
                                selected.classList.remove("selected");
                                selected.nextElementSibling.classList.add(
                                    "selected",
                                );
                                selected.nextElementSibling.scrollIntoView({
                                    block: "nearest",
                                });
                            }
                        } else if (e.key === "ArrowUp") {
                            e.preventDefault();
                            if (selected && selected.previousElementSibling) {
                                selected.classList.remove("selected");
                                selected.previousElementSibling.classList.add(
                                    "selected",
                                );
                                selected.previousElementSibling.scrollIntoView({
                                    block: "nearest",
                                });
                            }
                        } else if (e.key === "Enter") {
                            e.preventDefault();
                            if (selected) selected.click();
                        } else if (e.key === "Tab") {
                            e.preventDefault();
                            if (selected) {
                                const commandName =
                                    selected.querySelector(
                                        "span:first-child",
                                    ).textContent;
                                commandInput.value = commandName.startsWith(
                                    "Switch to: ",
                                )
                                    ? commandName.substring(11)
                                    : commandName;
                                commandInput.dispatchEvent(new Event("input")); // Trigger filtering
                            }
                        } else if (e.key === "Escape") {
                            closeCommandPalette();
                        }
                        return;
                    }

                    const isModifierKey = e.ctrlKey || e.metaKey;
                    if (isModifierKey) {
                        if (e.key >= "1" && e.key <= "9") {
                            e.preventDefault();
                            switchToBuffer(parseInt(e.key) - 1);
                            return;
                        }
                        if (e.key === "ArrowLeft") {
                            e.preventDefault();
                            const prevIndex =
                                activeBufferIndex > 0
                                    ? activeBufferIndex - 1
                                    : buffers.length - 1;
                            switchToBuffer(prevIndex);
                            return;
                        }
                        if (e.key === "ArrowRight") {
                            e.preventDefault();
                            const nextIndex =
                                activeBufferIndex < buffers.length - 1
                                    ? activeBufferIndex + 1
                                    : 0;
                            switchToBuffer(nextIndex);
                            return;
                        }

                        switch (e.key.toLowerCase()) {
                            case "s":
                                e.preventDefault();
                                saveFile();
                                break;
                            case "d":
                                e.preventDefault();
                                toggleDarkMode();
                                break;
                            case "o":
                                e.preventDefault();
                                openFile();
                                break;
                            case "n":
                                e.preventDefault();
                                newTab();
                                break;
                            case "w":
                                e.preventDefault();
                                closeBuffer(activeBufferIndex);
                                break;
                            case "=":
                                e.preventDefault();
                                await toggleLock();
                                break;
                            case "k":
                                e.preventDefault();
                                openCommandPalette();
                                break;
                        }
                    } else if (e.key === "F11") {
                        e.preventDefault();
                        toggleFullscreen();
                    } else if (e.key === "Escape") {
                        if (
                            helpModal &&
                            !helpModal.classList.contains("hidden")
                        ) {
                            closeHelpModal();
                        }
                    }
                });

                // Context Menu Listeners
                document.addEventListener("contextmenu", (e) => {
                    e.preventDefault();
                    const buffer = buffers[activeBufferIndex];
                    document.getElementById("ctxToggleLock").textContent =
                        buffer.isLocked ? "Unlock Note" : "Lock Note";
                    document.getElementById("ctxToggleDark").textContent =
                        document.body.classList.contains("dark-mode")
                            ? "Light Mode"
                            : "Dark Mode";
                    document.getElementById("ctxToggleFullscreen").textContent =
                        document.fullscreenElement
                            ? "Exit Fullscreen"
                            : "Fullscreen";
                    showContextMenu(e.clientX, e.clientY);
                });

                window.addEventListener("click", () => {
                    hideContextMenu();
                });

                document
                    .getElementById("ctxCommandPalette")
                    .addEventListener("click", () => {
                        openCommandPalette();
                        hideContextMenu();
                    });
                document
                    .getElementById("ctxNewTab")
                    .addEventListener("click", () => {
                        newTab();
                        hideContextMenu();
                    });
                document
                    .getElementById("ctxOpenFile")
                    .addEventListener("click", () => {
                        openFile();
                        hideContextMenu();
                    });
                document
                    .getElementById("ctxSaveFile")
                    .addEventListener("click", () => {
                        saveFile();
                        hideContextMenu();
                    });
                document
                    .getElementById("ctxCloseBuffer")
                    .addEventListener("click", () => {
                        closeBuffer(activeBufferIndex);
                        hideContextMenu();
                    });
                document
                    .getElementById("ctxToggleLock")
                    .addEventListener("click", async () => {
                        await toggleLock();
                        hideContextMenu();
                    });
                document
                    .getElementById("ctxToggleDark")
                    .addEventListener("click", () => {
                        toggleDarkMode();
                        hideContextMenu();
                    });
                document
                    .getElementById("ctxToggleFullscreen")
                    .addEventListener("click", () => {
                        toggleFullscreen();
                        hideContextMenu();
                    });
                document
                    .getElementById("ctxNextBuffer")
                    .addEventListener("click", () => {
                        const nextIndex =
                            activeBufferIndex < buffers.length - 1
                                ? activeBufferIndex + 1
                                : 0;
                        switchToBuffer(nextIndex);
                        hideContextMenu();
                    });
                document
                    .getElementById("ctxPrevBuffer")
                    .addEventListener("click", () => {
                        const prevIndex =
                            activeBufferIndex > 0
                                ? activeBufferIndex - 1
                                : buffers.length - 1;
                        switchToBuffer(prevIndex);
                        hideContextMenu();
                    });

                // Initialization
                initializeTabAndUrl();
                initializeBuffers();
                loadDarkMode();
                editor.focus();
            });
        </script>
        <script
            defer
            src="https://static.cloudflareinsights.com/beacon.min.js"
            data-cf-beacon='{"token": "4ff91f0f1de749c2a405a85ac2d12d29"}'
        ></script>
    </body>
</html>
