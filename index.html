<!doctype html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>bPad</title>
        <link
            rel="icon"
            href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' width='16' height='16' viewBox='0 0 16 16'><rect width='16' height='16' fill='%23666666'/><text x='8' y='12' font-family='monospace' font-size='12' fill='white' text-anchor='middle'>b</text></svg>"
        />
        <style>
            * {
                margin: 0;
                padding: 0;
                box-sizing: border-box;
            }

            body {
                font-family: "Courier New", monospace;
                background: #f8f8f8;
                height: 100vh;
                position: relative;
                transition: background 0.3s ease;
            }

            body.dark-mode {
                background: #1a1a1a;
            }

            #editor {
                width: 100%;
                height: 100vh;
                border: none;
                outline: none;
                padding: 20px;
                font-family: "Courier New", monospace;
                font-size: 14px;
                line-height: 1.5;
                background: white;
                color: #333;
                resize: none;
                white-space: pre-wrap;
                word-wrap: break-word;
                transition:
                    background 0.3s ease,
                    color 0.3s ease,
                    border 0.2s ease;
            }

            #editor.drag-over {
                border: 3px dashed #007acc;
                background: rgba(0, 122, 204, 0.1);
            }

            body.dark-mode #editor {
                background: #2d2d2d;
                color: #e0e0e0;
            }

            body.dark-mode #editor.drag-over {
                border: 3px dashed #4a9eff;
                background: rgba(74, 158, 255, 0.1);
            }

            #bufferBar {
                display: none;
            }

            #shortcuts {
                position: fixed;
                top: 10px;
                right: 10px;
                background: rgba(0, 0, 0, 0.8);
                color: white;
                padding: 10px;
                border-radius: 4px;
                font-size: 12px;
                opacity: 0;
                transition: opacity 0.3s;
                pointer-events: none;
                z-index: 1000;
            }

            #shortcuts.show {
                opacity: 1;
            }

            #hoverHint {
                position: fixed;
                top: 15px;
                right: 15px;
                width: 8px;
                height: 8px;
                background: rgba(0, 0, 0, 0.2);
                border-radius: 50%;
                transition: opacity 0.3s;
                pointer-events: none;
                z-index: 999;
            }

            body.dark-mode #hoverHint {
                background: rgba(255, 255, 255, 0.3);
            }

            #hoverHint.hide {
                opacity: 0;
            }

            #fileInput {
                display: none;
            }

            #mobileControls {
                position: fixed;
                top: 10px;
                right: 10px;
                display: none;
                gap: 8px;
                z-index: 1000;
            }

            .mobile-btn {
                width: 40px;
                height: 40px;
                background: rgba(0, 0, 0, 0.8);
                color: white;
                border: none;
                border-radius: 4px;
                cursor: pointer;
                display: flex;
                align-items: center;
                justify-content: center;
                font-size: 16px;
                transition: background 0.2s;
            }

            .mobile-btn:hover {
                background: rgba(0, 0, 0, 0.9);
            }

            .mobile-btn:active {
                transform: scale(0.95);
            }

            @media (max-width: 768px) {
                #mobileControls {
                    display: flex;
                }

                #shortcuts {
                    display: none;
                }

                #editor {
                    height: 100vh;
                }
            }

            #contextMenu {
                position: fixed;
                display: none;
                background: #f0f0f0;
                border: 1px solid #ccc;
                box-shadow: 2px 2px 5px rgba(0, 0, 0, 0.15);
                border-radius: 4px;
                padding: 5px 0;
                z-index: 2000;
                font-size: 14px;
                color: #333;
            }

            .context-menu-item {
                padding: 8px 15px;
                cursor: pointer;
                transition: background 0.2s ease;
            }

            .context-menu-item:hover {
                background: #007acc;
                color: white;
            }

            .context-menu-divider {
                border: none;
                border-top: 1px solid #e0e0e0;
                margin: 4px 0;
            }

            body.dark-mode #contextMenu {
                background: #3a3a3a;
                border-color: #555;
                color: #e0e0e0;
            }

            body.dark-mode .context-menu-item:hover {
                background: #4a9eff;
                color: #1a1a1a;
            }

            body.dark-mode .context-menu-divider {
                border-top-color: #555;
            }
        </style>
    </head>
    <body>
        <textarea id="editor" placeholder="..."></textarea>

        <div id="hoverHint"></div>

        <div id="shortcuts">
            <div>..................................</div>
            <div>bPad : browser Pad</div>
            <div>..................................</div>
            <div id="currentBuffer">Buffer: 1/1 - bpad.txt</div>
            <div id="wordCount">Words: 0 | Lines: 0</div>
            <div>..................................</div>
            <div>HELP</div>
            <div>Ctrl/Cmd + N : New tab</div>
            <div>bpad.me/abc : New note 'abc'</div>
            <div>Ctrl/Cmd + O : Open file</div>
            <div>Drag and drop to open file</div>
            <div>Opening file adds it to new buffer</div>
            <div>Ctrl/Cmd + 1~9 : Switch buffers</div>
            <div>Ctrl/Cmd + ‚Üê/‚Üí : Switch buffers</div>
            <div>Ctrl/Cmd + S : Save file</div>
            <div>Files auto save in browser</div>
            <div>Ctrl/Cmd + W : Close buffer</div>
            <div>Ctrl/Cmd + D : Dark/light mode</div>
            <div>Ctrl/Cmd + = : Lock/unlock note</div>
            <div>F11 : Full screen</div>
            <div>Right-click : Menu</div>
            <div>..................................</div>
            <div>Made by [Barney](www.barney.me)</div>
            <div>..................................</div>
        </div>

        <div id="contextMenu">
            <div class="context-menu-item" id="ctxNewTab">New Tab</div>
            <div class="context-menu-item" id="ctxOpenFile">Open File...</div>
            <div class="context-menu-item" id="ctxSaveFile">Save File</div>
            <hr class="context-menu-divider" />
            <div class="context-menu-item" id="ctxNextBuffer">Next Buffer</div>
            <div class="context-menu-item" id="ctxPrevBuffer">
                Previous Buffer
            </div>
            <div class="context-menu-item" id="ctxCloseBuffer">
                Close Buffer
            </div>
            <hr class="context-menu-divider" />
            <div class="context-menu-item" id="ctxToggleLock">
                Lock/Unlock Note
            </div>
            <div class="context-menu-item" id="ctxToggleDark">
                Toggle Dark Mode
            </div>
            <div class="context-menu-item" id="ctxToggleFullscreen">
                Fullscreen
            </div>
        </div>

        <div id="mobileControls">
            <button class="mobile-btn" id="openBtn" title="Open file">
                üìÅ
            </button>
            <button class="mobile-btn" id="saveBtn" title="Save file">
                üíæ
            </button>
        </div>

        <input type="file" id="fileInput" accept=".txt,.md,.js,.html,.css" />

        <script>
            // Wait for DOM to be fully loaded
            document.addEventListener("DOMContentLoaded", function () {
                // Get DOM elements
                const editor = document.getElementById("editor");
                const shortcuts = document.getElementById("shortcuts");
                const fileInput = document.getElementById("fileInput");
                const openBtn = document.getElementById("openBtn");
                const saveBtn = document.getElementById("saveBtn");
                const wordCount = document.getElementById("wordCount");
                const currentBuffer = document.getElementById("currentBuffer");
                const hoverHint = document.getElementById("hoverHint");
                const contextMenu = document.getElementById("contextMenu");

                // Crypto constants
                const ENCRYPTION_ALGORITHM = "AES-GCM";
                const KEY_DERIVATION_ALGORITHM = "PBKDF2";
                const HASH_ALGORITHM = "SHA-256";
                const KEY_DERIVATION_ITERATIONS = 100000;

                let showTimeout;
                let tabId; // This will be set by initializeTabAndUrl
                let buffers = [];
                let activeBufferIndex = 0;

                // NEW: This function handles Tab ID and URL logic on startup.
                function initializeTabAndUrl() {
                    const path = window.location.pathname;
                    const pathSegments = path
                        .split("/")
                        .filter(
                            (segment) => segment && segment !== "index.html",
                        );
                    const lastSegment =
                        pathSegments.length > 0
                            ? pathSegments[pathSegments.length - 1]
                            : null;

                    // A simple check to see if the last segment could be our ID (i.e., it doesn't have a file extension)
                    const hasIdInUrl =
                        lastSegment && !lastSegment.includes(".");

                    if (hasIdInUrl) {
                        // Case 1: An ID exists in the URL. Use it.
                        // This handles bookmarks, shared links, and tabs created with Ctrl+N.
                        tabId = lastSegment;
                        // Set this as the "main" tab ID for the next time the user visits the root URL.
                        localStorage.setItem("bedit_main_tabId", tabId);
                    } else {
                        // Case 2: No valid ID in the URL. We are at the root (e.g., /repo/ or /repo/index.html).
                        const storedMainId =
                            localStorage.getItem("bedit_main_tabId");
                        if (storedMainId) {
                            // A main ID was saved from a previous session. Use it and update the URL to match.
                            tabId = storedMainId;
                            const basePath = path.endsWith("/")
                                ? path
                                : path.substring(0, path.lastIndexOf("/") + 1);
                            window.history.replaceState(
                                {},
                                "",
                                `${basePath}${tabId}`,
                            );
                        } else {
                            // First visit ever, or local storage was cleared.
                            // Generate a new ID, store it as the main ID, and update the URL.
                            tabId = Math.random().toString(36).substr(2, 6);
                            localStorage.setItem("bedit_main_tabId", tabId);
                            const basePath = path.endsWith("/")
                                ? path
                                : path.substring(0, path.lastIndexOf("/") + 1);
                            window.history.replaceState(
                                {},
                                "",
                                `${basePath}${tabId}`,
                            );
                        }
                    }
                }

                // Helper function to get filename without extension for URL
                function getFileNameForUrl(fileName) {
                    const nameWithoutExt = fileName.replace(/\.[^/.]+$/, "");
                    return nameWithoutExt
                        .toLowerCase()
                        .replace(/[^a-z0-9]/g, "");
                }

                // Update URL based on current buffer
                function updateUrlForCurrentBuffer() {
                    const buffer = buffers[activeBufferIndex];
                    if (!buffer) return;

                    let urlPath;
                    if (buffer.name === "bpad.txt") {
                        urlPath = `/${tabId}`;
                    } else {
                        const urlName = getFileNameForUrl(buffer.name);
                        urlPath = `/${urlName}`;
                    }

                    // This logic needs to be aware of the base path for GitHub pages
                    const currentPath = window.location.pathname;
                    const basePath = currentPath.substring(
                        0,
                        currentPath.lastIndexOf("/") + 1,
                    );
                    const newPath = `${basePath}${urlPath.substring(1)}`;

                    if (window.location.pathname !== newPath) {
                        window.history.replaceState({}, "", newPath);
                    }
                }

                // Buffer class
                class FileBuffer {
                    constructor(
                        name = "bpad.txt",
                        content = "",
                        fileHandle = null,
                        isLocked = false,
                        encryptedContent = null,
                        salt = null,
                        iv = null,
                    ) {
                        this.name = name;
                        this.content = content;
                        this.originalContent = content;
                        this.fileHandle = fileHandle;
                        this.id = Math.random().toString(36).substr(2, 9);
                        this.isLocked = isLocked;
                        this.encryptedContent = encryptedContent;
                        this.salt = salt;
                        this.iv = iv;
                    }

                    get isModified() {
                        if (this.isLocked) return false;
                        return this.content !== this.originalContent;
                    }

                    markSaved() {
                        this.originalContent = this.content;
                    }
                }

                // Crypto Helper Functions
                async function deriveKey(password, salt) {
                    const enc = new TextEncoder();
                    const keyMaterial = await window.crypto.subtle.importKey(
                        "raw",
                        enc.encode(password),
                        { name: KEY_DERIVATION_ALGORITHM },
                        false,
                        ["deriveKey"],
                    );
                    return window.crypto.subtle.deriveKey(
                        {
                            name: KEY_DERIVATION_ALGORITHM,
                            salt: salt,
                            iterations: KEY_DERIVATION_ITERATIONS,
                            hash: HASH_ALGORITHM,
                        },
                        keyMaterial,
                        { name: ENCRYPTION_ALGORITHM, length: 256 },
                        true,
                        ["encrypt", "decrypt"],
                    );
                }

                async function encryptText(text, password) {
                    const salt = window.crypto.getRandomValues(
                        new Uint8Array(16),
                    );
                    const iv = window.crypto.getRandomValues(
                        new Uint8Array(12),
                    );
                    const key = await deriveKey(password, salt);
                    const enc = new TextEncoder();
                    const encodedText = enc.encode(text);
                    const encryptedContent = await window.crypto.subtle.encrypt(
                        { name: ENCRYPTION_ALGORITHM, iv: iv },
                        key,
                        encodedText,
                    );
                    return {
                        encryptedContent: btoa(
                            String.fromCharCode.apply(
                                null,
                                new Uint8Array(encryptedContent),
                            ),
                        ),
                        salt: btoa(String.fromCharCode.apply(null, salt)),
                        iv: btoa(String.fromCharCode.apply(null, iv)),
                    };
                }

                async function decryptText(
                    encryptedContentB64,
                    password,
                    saltB64,
                    ivB64,
                ) {
                    try {
                        const salt = new Uint8Array(
                            atob(saltB64)
                                .split("")
                                .map((c) => c.charCodeAt(0)),
                        );
                        const iv = new Uint8Array(
                            atob(ivB64)
                                .split("")
                                .map((c) => c.charCodeAt(0)),
                        );
                        const encryptedContent = new Uint8Array(
                            atob(encryptedContentB64)
                                .split("")
                                .map((c) => c.charCodeAt(0)),
                        );

                        const key = await deriveKey(password, salt);
                        const decryptedContent =
                            await window.crypto.subtle.decrypt(
                                { name: ENCRYPTION_ALGORITHM, iv: iv },
                                key,
                                encryptedContent,
                            );

                        const dec = new TextDecoder();
                        return dec.decode(decryptedContent);
                    } catch (e) {
                        console.error("Decryption failed:", e);
                        return null;
                    }
                }

                // Save/Load all buffers to/from localStorage
                function saveBuffersToLocalStorage() {
                    const buffersToSave = buffers.map((buffer) => ({
                        name: buffer.name,
                        content: buffer.isLocked ? "" : buffer.content,
                        originalContent: buffer.originalContent,
                        isLocked: buffer.isLocked,
                        encryptedContent: buffer.encryptedContent,
                        salt: buffer.salt,
                        iv: buffer.iv,
                    }));
                    localStorage.setItem(
                        `bedit_buffers_${tabId}`,
                        JSON.stringify(buffersToSave),
                    );
                    localStorage.setItem(
                        `bedit_active_buffer_index_${tabId}`,
                        activeBufferIndex,
                    );
                }

                function initializeBuffers() {
                    const savedBuffersData = localStorage.getItem(
                        `bedit_buffers_${tabId}`,
                    );
                    if (savedBuffersData) {
                        const savedBuffers = JSON.parse(savedBuffersData);
                        buffers = savedBuffers.map(
                            (b) =>
                                new FileBuffer(
                                    b.name,
                                    b.content,
                                    null,
                                    b.isLocked,
                                    b.encryptedContent,
                                    b.salt,
                                    b.iv,
                                ),
                        );
                        activeBufferIndex =
                            parseInt(
                                localStorage.getItem(
                                    `bedit_active_buffer_index_${tabId}`,
                                ),
                                10,
                            ) || 0;
                        if (activeBufferIndex >= buffers.length)
                            activeBufferIndex = 0;
                    } else {
                        const oldContentKey = `bedit_${tabId}_editorContent`;
                        const savedContent =
                            localStorage.getItem(oldContentKey) || "";
                        buffers = [new FileBuffer("bpad.txt", savedContent)];
                        activeBufferIndex = 0;
                        if (localStorage.getItem(oldContentKey)) {
                            saveBuffersToLocalStorage();
                            localStorage.removeItem(oldContentKey);
                        }
                    }

                    if (buffers.length === 0) {
                        buffers = [new FileBuffer("bpad.txt", "")];
                        activeBufferIndex = 0;
                    }

                    updateBufferBar();
                    loadActiveBuffer();
                    // updateUrlForCurrentBuffer(); // This might be redundant now
                }

                // Buffer management functions
                function createNewBuffer(
                    name = "bpad.txt",
                    content = "",
                    fileHandle = null,
                ) {
                    const buffer = new FileBuffer(name, content, fileHandle);
                    buffers.push(buffer);
                    activeBufferIndex = buffers.length - 1;
                    updateBufferBar();
                    loadActiveBuffer();
                    updateUrlForCurrentBuffer();
                    saveBuffersToLocalStorage();
                    return buffer;
                }

                function switchToBuffer(index) {
                    if (index < 0 || index >= buffers.length) return;
                    const currentBuf = buffers[activeBufferIndex];
                    if (currentBuf && !currentBuf.isLocked) {
                        currentBuf.content = editor.value;
                    }
                    activeBufferIndex = index;
                    loadActiveBuffer();
                    updateBufferBar();
                    updateUrlForCurrentBuffer();
                    saveBuffersToLocalStorage();
                }

                function closeBuffer(index) {
                    if (buffers.length === 1) return;
                    const buffer = buffers[index];
                    if (buffer.isModified && !buffer.isLocked) {
                        if (
                            !confirm(
                                `"${buffer.name}" has unsaved changes. Close anyway?`,
                            )
                        ) {
                            return;
                        }
                    }
                    buffers.splice(index, 1);
                    if (activeBufferIndex >= index && activeBufferIndex > 0) {
                        activeBufferIndex--;
                    } else if (activeBufferIndex >= buffers.length) {
                        activeBufferIndex = buffers.length - 1;
                    }
                    updateBufferBar();
                    loadActiveBuffer();
                    updateUrlForCurrentBuffer();
                    saveBuffersToLocalStorage();
                }

                function loadActiveBuffer() {
                    const buffer = buffers[activeBufferIndex];
                    if (buffer) {
                        if (buffer.isLocked) {
                            editor.value = "";
                            editor.placeholder =
                                "üîí This note is locked. Press Ctrl/Cmd + = to unlock.";
                            editor.readOnly = true;
                        } else {
                            editor.value = buffer.content;
                            editor.placeholder = "...";
                            editor.readOnly = false;
                        }
                        updateWordCount();
                        updateBufferBar();
                        editor.focus();
                    }
                }

                function updateBufferBar() {
                    if (currentBuffer) {
                        const buffer = buffers[activeBufferIndex];
                        if (!buffer) return;
                        const modifiedText =
                            buffer.isModified && !buffer.isLocked
                                ? " (modified)"
                                : "";
                        const lockedText = buffer.isLocked ? " üîí" : "";
                        currentBuffer.textContent = `Buffer: ${
                            activeBufferIndex + 1
                        }/${buffers.length} - ${
                            buffer.name
                        }${lockedText}${modifiedText}`;
                    }
                }

                // Dark mode functions
                function loadDarkMode() {
                    const isDarkMode =
                        localStorage.getItem("darkMode") === "true";
                    if (isDarkMode) {
                        document.body.classList.add("dark-mode");
                    }
                }

                function toggleDarkMode() {
                    document.body.classList.toggle("dark-mode");
                    const isDarkMode =
                        document.body.classList.contains("dark-mode");
                    localStorage.setItem("darkMode", isDarkMode);
                }

                // Update word count
                function updateWordCount() {
                    const text = editor.value;
                    const words =
                        text.trim() === ""
                            ? 0
                            : text.trim().split(/\s+/).length;
                    const lines = text === "" ? 0 : text.split("\n").length;
                    wordCount.textContent = `Words: ${words} | Lines: ${lines}`;
                }

                // Save file function
                async function saveFile() {
                    const buffer = buffers[activeBufferIndex];
                    if (!buffer) return;

                    if (buffer.isLocked) {
                        showSaveIndicator("Cannot save a locked note!");
                        return;
                    }

                    const content = editor.value;
                    buffer.content = content;

                    if ("showSaveFilePicker" in window && buffer.fileHandle) {
                        try {
                            const writable =
                                await buffer.fileHandle.createWritable();
                            await writable.write(content);
                            await writable.close();
                            buffer.markSaved();
                            updateBufferBar();
                            showSaveIndicator("Saved!");
                            return;
                        } catch (err) {
                            console.log("Direct save failed:", err);
                        }
                    }

                    if ("showSaveFilePicker" in window && !buffer.fileHandle) {
                        try {
                            buffer.fileHandle = await window.showSaveFilePicker(
                                {
                                    suggestedName: buffer.name,
                                    types: [
                                        {
                                            description: "Text files",
                                            accept: { "text/plain": [".txt"] },
                                        },
                                    ],
                                },
                            );
                            const writable =
                                await buffer.fileHandle.createWritable();
                            await writable.write(content);
                            await writable.close();
                            buffer.name = buffer.fileHandle.name;
                            buffer.markSaved();
                            updateBufferBar();
                            updateUrlForCurrentBuffer();
                            showSaveIndicator("Saved!");
                            return;
                        } catch (err) {
                            if (err.name !== "AbortError") {
                                console.log("Save picker failed:", err);
                            }
                        }
                    }

                    const blob = new Blob([content], { type: "text/plain" });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement("a");
                    a.href = url;
                    a.download = buffer.name;
                    a.click();
                    URL.revokeObjectURL(url);
                    buffer.markSaved();
                    updateBufferBar();
                    showSaveIndicator("Downloaded!");
                }

                // Show save success indicator
                function showSaveIndicator(message) {
                    let indicator = document.getElementById("saveIndicator");
                    if (!indicator) {
                        indicator = document.createElement("div");
                        indicator.id = "saveIndicator";
                        indicator.style.cssText = `
                            position: fixed; top: 20px; left: 50%;
                            transform: translateX(-50%); background: rgba(0, 150, 0, 0.9);
                            color: white; padding: 8px 16px; border-radius: 4px;
                            font-size: 14px; z-index: 2000; opacity: 0;
                            transition: opacity 0.3s; pointer-events: none;
                        `;
                        document.body.appendChild(indicator);
                    }
                    indicator.textContent = message;
                    indicator.style.opacity = "1";
                    setTimeout(() => {
                        indicator.style.opacity = "0";
                    }, 2000);
                }

                // Open file function
                async function openFile() {
                    if ("showOpenFilePicker" in window) {
                        try {
                            const [handle] = await window.showOpenFilePicker({
                                multiple: false,
                            });
                            const file = await handle.getFile();
                            const content = await file.text();
                            createNewBuffer(file.name, content, handle);
                            return;
                        } catch (err) {
                            if (err.name !== "AbortError") {
                                console.log("File picker failed:", err);
                            }
                        }
                    } else {
                        fileInput.click();
                    }
                }

                // Function to toggle lock state
                async function toggleLock() {
                    const buffer = buffers[activeBufferIndex];
                    if (!buffer) return;

                    if (buffer.isLocked) {
                        const password = prompt("Enter password to unlock:");
                        if (!password) return;
                        const decryptedContent = await decryptText(
                            buffer.encryptedContent,
                            password,
                            buffer.salt,
                            buffer.iv,
                        );
                        if (decryptedContent !== null) {
                            buffer.content = decryptedContent;
                            buffer.isLocked = false;
                            buffer.encryptedContent = null;
                            buffer.salt = null;
                            buffer.iv = null;
                            showSaveIndicator("Note unlocked!");
                        } else {
                            alert("Decryption failed. Incorrect password.");
                            return;
                        }
                    } else {
                        const password = prompt("Enter password to lock note:");
                        if (!password) {
                            alert("Password cannot be empty.");
                            return;
                        }
                        const passwordConfirm = prompt("Confirm password:");
                        if (password !== passwordConfirm) {
                            alert("Passwords do not match.");
                            return;
                        }
                        const { encryptedContent, salt, iv } =
                            await encryptText(editor.value, password);
                        buffer.encryptedContent = encryptedContent;
                        buffer.salt = salt;
                        buffer.iv = iv;
                        buffer.isLocked = true;
                        buffer.content = "";
                        showSaveIndicator("Note locked!");
                    }

                    saveBuffersToLocalStorage();
                    loadActiveBuffer();
                }

                // UPDATED: New tab function that is robust for subdirectories (like on GitHub Pages)
                function newTab() {
                    const newId = Math.random().toString(36).substr(2, 6);
                    const currentPath = window.location.pathname;
                    // Find the base path by removing the current file/id from the end
                    const basePath = currentPath.substring(
                        0,
                        currentPath.lastIndexOf("/") + 1,
                    );
                    const newUrl = `${window.location.origin}${basePath}${newId}`;
                    window.open(newUrl, "_blank");
                }

                // Toggle fullscreen
                function toggleFullscreen() {
                    if (!document.fullscreenElement) {
                        document.documentElement.requestFullscreen();
                    } else {
                        document.exitFullscreen();
                    }
                }

                // --- Context Menu Logic ---
                function showContextMenu(x, y) {
                    contextMenu.style.left = `${x}px`;
                    contextMenu.style.top = `${y}px`;
                    contextMenu.style.display = "block";
                }

                function hideContextMenu() {
                    contextMenu.style.display = "none";
                }

                // Event Listeners
                editor.addEventListener("input", function () {
                    const buffer = buffers[activeBufferIndex];
                    if (buffer && !buffer.isLocked) {
                        buffer.content = editor.value;
                        updateBufferBar();
                        saveBuffersToLocalStorage();
                    }
                    updateWordCount();
                });

                fileInput.addEventListener("change", (e) => {
                    if (e.target.files[0]) loadFileContent(e.target.files[0]);
                });

                function loadFileContent(file) {
                    const reader = new FileReader();
                    reader.onload = (e) =>
                        createNewBuffer(file.name, e.target.result, null);
                    reader.readAsText(file);
                }

                // Drag and drop
                editor.addEventListener("dragover", (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    editor.classList.add("drag-over");
                });
                editor.addEventListener("dragleave", (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    if (!editor.contains(e.relatedTarget)) {
                        editor.classList.remove("drag-over");
                    }
                });
                editor.addEventListener("drop", (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    editor.classList.remove("drag-over");
                    if (e.dataTransfer.files.length > 0) {
                        loadFileContent(e.dataTransfer.files[0]);
                    }
                });

                // Mobile buttons
                openBtn.addEventListener("click", openFile);
                saveBtn.addEventListener("click", saveFile);

                // Mouse hover for shortcuts
                document.addEventListener("mousemove", (e) => {
                    if (
                        e.clientX > window.innerWidth - 100 &&
                        e.clientY < 100
                    ) {
                        shortcuts.classList.add("show");
                        hoverHint.classList.add("hide");
                        clearTimeout(showTimeout);
                    } else {
                        showTimeout = setTimeout(() => {
                            shortcuts.classList.remove("show");
                            hoverHint.classList.remove("hide");
                        }, 1000);
                    }
                });

                // Keyboard shortcuts
                document.addEventListener("keydown", async (e) => {
                    const isModifierKey = e.ctrlKey || e.metaKey;
                    if (isModifierKey) {
                        if (e.key >= "1" && e.key <= "9") {
                            e.preventDefault();
                            switchToBuffer(parseInt(e.key) - 1);
                            return;
                        }
                        if (e.key === "ArrowLeft") {
                            e.preventDefault();
                            const prevIndex =
                                activeBufferIndex > 0
                                    ? activeBufferIndex - 1
                                    : buffers.length - 1;
                            switchToBuffer(prevIndex);
                            return;
                        }
                        if (e.key === "ArrowRight") {
                            e.preventDefault();
                            const nextIndex =
                                activeBufferIndex < buffers.length - 1
                                    ? activeBufferIndex + 1
                                    : 0;
                            switchToBuffer(nextIndex);
                            return;
                        }

                        switch (e.key.toLowerCase()) {
                            case "s":
                                e.preventDefault();
                                saveFile();
                                break;
                            case "d":
                                e.preventDefault();
                                toggleDarkMode();
                                break;
                            case "o":
                                e.preventDefault();
                                openFile();
                                break;
                            case "n":
                                e.preventDefault();
                                newTab();
                                break;
                            case "w":
                                e.preventDefault();
                                closeBuffer(activeBufferIndex);
                                break;
                            case "=":
                                e.preventDefault();
                                await toggleLock();
                                break;
                        }
                    } else if (e.key === "F11") {
                        e.preventDefault();
                        toggleFullscreen();
                    }
                });

                // Context Menu Listeners
                document.addEventListener("contextmenu", (e) => {
                    e.preventDefault();
                    // Update menu item text based on current state
                    const buffer = buffers[activeBufferIndex];
                    document.getElementById("ctxToggleLock").textContent =
                        buffer.isLocked ? "Unlock Note" : "Lock Note";
                    document.getElementById("ctxToggleDark").textContent =
                        document.body.classList.contains("dark-mode")
                            ? "Light Mode"
                            : "Dark Mode";
                    document.getElementById("ctxToggleFullscreen").textContent =
                        document.fullscreenElement
                            ? "Exit Fullscreen"
                            : "Fullscreen";

                    showContextMenu(e.clientX, e.clientY);
                });

                window.addEventListener("click", () => {
                    hideContextMenu();
                });

                document
                    .getElementById("ctxNewTab")
                    .addEventListener("click", () => {
                        newTab();
                        hideContextMenu();
                    });
                document
                    .getElementById("ctxOpenFile")
                    .addEventListener("click", () => {
                        openFile();
                        hideContextMenu();
                    });
                document
                    .getElementById("ctxSaveFile")
                    .addEventListener("click", () => {
                        saveFile();
                        hideContextMenu();
                    });
                document
                    .getElementById("ctxCloseBuffer")
                    .addEventListener("click", () => {
                        closeBuffer(activeBufferIndex);
                        hideContextMenu();
                    });
                document
                    .getElementById("ctxToggleLock")
                    .addEventListener("click", async () => {
                        await toggleLock();
                        hideContextMenu();
                    });
                document
                    .getElementById("ctxToggleDark")
                    .addEventListener("click", () => {
                        toggleDarkMode();
                        hideContextMenu();
                    });
                document
                    .getElementById("ctxToggleFullscreen")
                    .addEventListener("click", () => {
                        toggleFullscreen();
                        hideContextMenu();
                    });

                document
                    .getElementById("ctxNextBuffer")
                    .addEventListener("click", () => {
                        const nextIndex =
                            activeBufferIndex < buffers.length - 1
                                ? activeBufferIndex + 1
                                : 0;
                        switchToBuffer(nextIndex);
                        hideContextMenu();
                    });

                document
                    .getElementById("ctxPrevBuffer")
                    .addEventListener("click", () => {
                        const prevIndex =
                            activeBufferIndex > 0
                                ? activeBufferIndex - 1
                                : buffers.length - 1;
                        switchToBuffer(prevIndex);
                        hideContextMenu();
                    });

                // UPDATED: Initialization Order
                initializeTabAndUrl(); // This now runs first to set up the correct tabId
                initializeBuffers(); // This uses the tabId to load the right content
                loadDarkMode();
                editor.focus();
            });
        </script>
        <script
            defer
            src="https://static.cloudflareinsights.com/beacon.min.js"
            data-cf-beacon='{"token": "4ff91f0f1de749c2a405a85ac2d12d29"}'
        ></script>
    </body>
</html>
